/*
   Program to load a payload into a MCS-48 Microcontroller with an Arduino Nano
*/

#include <avr/io.h>

uint8_t payload[1024] =
{
  // Put your Payload (8bit HEX-Values separated by a ",") here and adjust the size of the array and the for-loops in the program-routine accordingly
  0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
  0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
  0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
  0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF

} ;

int VDD = A0;
int PROG = A1;
int TEST0 = A2;
int RESET = A3;
int EA = A4;
int BUTTON = A5;
int LED = 13;
int DataBus0 = 2;
int DataBus1 = 3;
int DataBus2 = 4;
int DataBus3 = 5;
int DataBus4 = 6;
int DataBus5 = 7;
int DataBus6 = 8;
int DataBus7 = 9;
int P20 = 10;
int P21 = 11;
int P22 = 12;

uint8_t LOWBYTE = 0;
uint8_t HIGHBYTE = 0;


void setup() {
  // Setup the Control-Pins
  Serial.begin(115200);
  pinMode(LED, OUTPUT);
  digitalWrite(LED, LOW);
  pinMode(VDD, OUTPUT);
  pinMode(PROG, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  pinMode(EA, OUTPUT);
  pinMode(BUTTON, INPUT_PULLUP);
  // Setup the Address-/Data-Pins to INPUT, to keep them floating for now
  DDRD = DDRD | B00000000;
  DDRB = B00000000;
  // Set the control-Pins according to MCS-48 recommendation
  digitalWrite(VDD, LOW); // Set VDD to +5V
  digitalWrite(PROG, LOW); // Set PROG to +5V
  digitalWrite(TEST0, HIGH); // Set TEST0 to +5V
  digitalWrite(EA, LOW); // Set EA to +5V
  digitalWrite(RESET, LOW); // Set RESET to 0V
  digitalWrite(LED, HIGH);
  delay(3000);
  digitalWrite(LED, LOW);
  delay(1000);
  Serial.println("MCS-48 Programmer READY");
}

void loop() {
  if (digitalRead(BUTTON) == LOW) {
    Serial.println("button pressed");
    delay(1000);
    /*
    Serial.println("Dumping Chip in 5 seconds");
    delay(5000);
    dump();
    Serial.println("Verifying Chip in 5 seconds");
    delay(5000);
    verify();
    */
    Serial.println("Programming Chip in 5 Seconds");
    delay(5000);
    programverify();
  }
  /*
    // put your main code here, to run repeatedly:
    if (digitalRead(BUTTON) == LOW) {
    Serial.println("Programming Chip in 5 Seconds");
    delay(5000);
    program();
    }

    else {
    digitalWrite(LED, HIGH);
    delay(100);
    digitalWrite(LED, LOW);
    delay(100);
    }
  */
}

void programverify() {

  pinMode(LED, OUTPUT);
  pinMode(VDD, OUTPUT);
  pinMode(PROG, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  digitalWrite(TEST0, HIGH); //test0 to 5v
  digitalWrite(EA, HIGH); // apply +18V to EA to activate Programming-Mode
  digitalWrite(RESET, HIGH); //reset high while doing nothing
  digitalWrite(VDD, LOW); //low unless programming
  digitalWrite(PROG, LOW); //low unless programming

  pinMode(P20, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P21, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P22, OUTPUT); //extra address lines more than the data bus can accomodate

  for (uint16_t i = 0; i < 1024; i++) {
    // Setup the pins as outputs
    pinMode(DataBus0, OUTPUT);
    pinMode(DataBus1, OUTPUT);
    pinMode(DataBus2, OUTPUT);
    pinMode(DataBus3, OUTPUT);
    pinMode(DataBus4, OUTPUT);
    pinMode(DataBus5, OUTPUT);
    pinMode(DataBus6, OUTPUT);
    pinMode(DataBus7, OUTPUT);
    Serial.print("Programming Address ");
    Serial.print(i, HEX);


    digitalWrite(RESET, LOW); //reset low while setting addresses
    digitalWrite(TEST0, LOW); //test0 to 0v for programming


    //set address lines to bits in the address (remember, we have 10 bits in the 8041 and 11 in the 8042)
    digitalWrite(DataBus0, i & 0x0001);
    digitalWrite(DataBus1, i & 0x0002);
    digitalWrite(DataBus2, i & 0x0004);
    digitalWrite(DataBus3, i & 0x0008);
    digitalWrite(DataBus4, i & 0x0010);
    digitalWrite(DataBus5, i & 0x0020);
    digitalWrite(DataBus6, i & 0x0040);
    digitalWrite(DataBus7, i & 0x0080);
    digitalWrite(P20, i & 0x0100);
    digitalWrite(P21, i & 0x0200);
    digitalWrite(P22, i & 0x0400);

    delay(10);                         // Wait 10ms to have stable lines (Taw)
    digitalWrite(RESET, HIGH);        // Latch the Address into the MCS-48 µC
    delay(10);                         // Give the µC some time to latch the Address (Twa)

    Serial.print("   For Data ");
    Serial.print(payload[i], HEX);

    digitalWrite(DataBus0, payload[i] & 0x0001);
    digitalWrite(DataBus1, payload[i] & 0x0002);
    digitalWrite(DataBus2, payload[i] & 0x0004);
    digitalWrite(DataBus3, payload[i] & 0x0008);
    digitalWrite(DataBus4, payload[i] & 0x0010);
    digitalWrite(DataBus5, payload[i] & 0x0020);
    digitalWrite(DataBus6, payload[i] & 0x0040);
    digitalWrite(DataBus7, payload[i] & 0x0080);

    delay(10);                         // Wait 10ms to have stable lines (Tdw)
    digitalWrite(VDD, HIGH); //getting ready to program
    delay(10);                         // Wait 10ms to have stable lines (Tvddw)
    digitalWrite(PROG, HIGH); //programming
    delay(10);                         // Wait 10ms to have stable lines (Tpw)
    digitalWrite(PROG, LOW); //programming over
    delay(10);                         // Wait 10ms to have stable lines (Tvddh)
    digitalWrite(VDD, LOW); //finish programming
    delay(10);                         // Wait 10ms to have stable lines (Twt)

    //verifying

    pinMode(DataBus0, INPUT_PULLUP);
    pinMode(DataBus1, INPUT_PULLUP);
    pinMode(DataBus2, INPUT_PULLUP);
    pinMode(DataBus3, INPUT_PULLUP);
    pinMode(DataBus4, INPUT_PULLUP);
    pinMode(DataBus5, INPUT_PULLUP);
    pinMode(DataBus6, INPUT_PULLUP);
    pinMode(DataBus7, INPUT_PULLUP);
    digitalWrite(TEST0, HIGH); //test0 to 5v for reading
    delay(25);                         // Wait 25ms to have stable lines (Tdo)
    uint8_t VERIFY = 0;
    if (digitalRead(DataBus0)) {
      VERIFY = VERIFY + 0x01;
    }
    if (digitalRead(DataBus1)) {
      VERIFY = VERIFY + 0x02;
    }
    if (digitalRead(DataBus2)) {
      VERIFY = VERIFY + 0x04;
    }
    if (digitalRead(DataBus3)) {
      VERIFY = VERIFY + 0x08;
    }
    if (digitalRead(DataBus4)) {
      VERIFY = VERIFY + 0x10;
    }
    if (digitalRead(DataBus5)) {
      VERIFY = VERIFY + 0x20;
    }
    if (digitalRead(DataBus6)) {
      VERIFY = VERIFY + 0x40;
    }
    if (digitalRead(DataBus7)) {
      VERIFY = VERIFY + 0x80;
    }


    Serial.print(" Read: ");
    Serial.print(VERIFY, HEX);
    if (VERIFY == payload[i]) {
      Serial.println(" OK");
      digitalWrite(LED, HIGH);
    }
    else {
      Serial.println(" ERROR");
      // error();
    }
    digitalWrite(RESET, LOW);

  }
  digitalWrite(TEST0, LOW);
  digitalWrite(EA, LOW);
}

void verify() {

  pinMode(LED, OUTPUT);
  pinMode(VDD, OUTPUT);
  pinMode(PROG, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  digitalWrite(TEST0, HIGH); //test0 to 5v
  digitalWrite(EA, HIGH); // apply +18V to EA to activate Programming-Mode
  digitalWrite(RESET, HIGH); //reset high while doing nothing

  pinMode(P20, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P21, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P22, OUTPUT); //extra address lines more than the data bus can accomodate

  for (uint16_t i = 0; i < 1024; i++) {
    // Setup the pins as outputs
    pinMode(DataBus0, OUTPUT);
    pinMode(DataBus1, OUTPUT);
    pinMode(DataBus2, OUTPUT);
    pinMode(DataBus3, OUTPUT);
    pinMode(DataBus4, OUTPUT);
    pinMode(DataBus5, OUTPUT);
    pinMode(DataBus6, OUTPUT);
    pinMode(DataBus7, OUTPUT);
    Serial.print("Reading Address ");
    Serial.print(i, HEX);


    digitalWrite(RESET, LOW); //reset low while setting addresses


    //set address lines to bits in the address (remember, we have 10 bits in the 8041 and 11 in the 8042)
    digitalWrite(DataBus0, i & 0x0001);
    digitalWrite(DataBus1, i & 0x0002);
    digitalWrite(DataBus2, i & 0x0004);
    digitalWrite(DataBus3, i & 0x0008);
    digitalWrite(DataBus4, i & 0x0010);
    digitalWrite(DataBus5, i & 0x0020);
    digitalWrite(DataBus6, i & 0x0040);
    digitalWrite(DataBus7, i & 0x0080);
    digitalWrite(P20, i & 0x0100);
    digitalWrite(P21, i & 0x0200);
    digitalWrite(P22, i & 0x0400);

    delay(10);                         // Wait 1ms to have stable lines (Taw)
    digitalWrite(RESET, HIGH);        // Latch the Address into the MCS-48 µC
    delay(10);                         // Give the µC some time to latch the Address (Twa)

    Serial.print("   For Data ");
    Serial.print(payload[i], HEX);

    pinMode(DataBus0, INPUT_PULLUP);
    pinMode(DataBus1, INPUT_PULLUP);
    pinMode(DataBus2, INPUT_PULLUP);
    pinMode(DataBus3, INPUT_PULLUP);
    pinMode(DataBus4, INPUT_PULLUP);
    pinMode(DataBus5, INPUT_PULLUP);
    pinMode(DataBus6, INPUT_PULLUP);
    pinMode(DataBus7, INPUT_PULLUP);
    delay(25);
    uint8_t VERIFY = 0;
    if (digitalRead(DataBus0)) {
      VERIFY = VERIFY + 0x01;
    }
    if (digitalRead(DataBus1)) {
      VERIFY = VERIFY + 0x02;
    }
    if (digitalRead(DataBus2)) {
      VERIFY = VERIFY + 0x04;
    }
    if (digitalRead(DataBus3)) {
      VERIFY = VERIFY + 0x08;
    }
    if (digitalRead(DataBus4)) {
      VERIFY = VERIFY + 0x10;
    }
    if (digitalRead(DataBus5)) {
      VERIFY = VERIFY + 0x20;
    }
    if (digitalRead(DataBus6)) {
      VERIFY = VERIFY + 0x40;
    }
    if (digitalRead(DataBus7)) {
      VERIFY = VERIFY + 0x80;
    }


    Serial.print(" Read: ");
    Serial.print(VERIFY, HEX);
    if (VERIFY == payload[i]) {
      Serial.println(" OK");
      digitalWrite(LED, HIGH);
    }
    else {
      Serial.println(" ERROR");
      // error();
    }
    digitalWrite(RESET, LOW);

  }
  digitalWrite(TEST0, LOW);
  digitalWrite(EA, LOW);
}


void dump() {

  pinMode(LED, OUTPUT);
  pinMode(VDD, OUTPUT);
  pinMode(PROG, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  digitalWrite(TEST0, HIGH); //test0 to 5v
  digitalWrite(EA, HIGH); // apply +18V to EA to activate Programming-Mode
  digitalWrite(RESET, HIGH); //reset high while doing nothing

  pinMode(P20, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P21, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P22, OUTPUT); //extra address lines more than the data bus can accomodate

  for (uint16_t i = 0; i < 1024; i++) {
    // Setup the pins as outputs
    pinMode(DataBus0, OUTPUT);
    pinMode(DataBus1, OUTPUT);
    pinMode(DataBus2, OUTPUT);
    pinMode(DataBus3, OUTPUT);
    pinMode(DataBus4, OUTPUT);
    pinMode(DataBus5, OUTPUT);
    pinMode(DataBus6, OUTPUT);
    pinMode(DataBus7, OUTPUT);
    //Serial.print("Reading Address ");
    Serial.print(i, HEX);


    digitalWrite(RESET, LOW); //reset low while setting addresses


    //set address lines to bits in the address (remember, we have 10 bits in the 8041 and 11 in the 8042)
    digitalWrite(DataBus0, i & 0x0001);
    digitalWrite(DataBus1, i & 0x0002);
    digitalWrite(DataBus2, i & 0x0004);
    digitalWrite(DataBus3, i & 0x0008);
    digitalWrite(DataBus4, i & 0x0010);
    digitalWrite(DataBus5, i & 0x0020);
    digitalWrite(DataBus6, i & 0x0040);
    digitalWrite(DataBus7, i & 0x0080);
    digitalWrite(P20, i & 0x0100);
    digitalWrite(P21, i & 0x0200);
    digitalWrite(P22, i & 0x0400);

    delay(10);                         // Wait 1ms to have stable lines (Taw)
    digitalWrite(RESET, HIGH);        // Latch the Address into the MCS-48 µC
    delay(10);                         // Give the µC some time to latch the Address (Twa)

    pinMode(DataBus0, INPUT_PULLUP);
    pinMode(DataBus1, INPUT_PULLUP);
    pinMode(DataBus2, INPUT_PULLUP);
    pinMode(DataBus3, INPUT_PULLUP);
    pinMode(DataBus4, INPUT_PULLUP);
    pinMode(DataBus5, INPUT_PULLUP);
    pinMode(DataBus6, INPUT_PULLUP);
    pinMode(DataBus7, INPUT_PULLUP);
    delay(25);
    uint8_t VERIFY = 0;
    if (digitalRead(DataBus0)) {
      VERIFY = VERIFY + 0x01;
    }
    if (digitalRead(DataBus1)) {
      VERIFY = VERIFY + 0x02;
    }
    if (digitalRead(DataBus2)) {
      VERIFY = VERIFY + 0x04;
    }
    if (digitalRead(DataBus3)) {
      VERIFY = VERIFY + 0x08;
    }
    if (digitalRead(DataBus4)) {
      VERIFY = VERIFY + 0x10;
    }
    if (digitalRead(DataBus5)) {
      VERIFY = VERIFY + 0x20;
    }
    if (digitalRead(DataBus6)) {
      VERIFY = VERIFY + 0x40;
    }
    if (digitalRead(DataBus7)) {
      VERIFY = VERIFY + 0x80;
    }


    Serial.print(" : ");
    Serial.println(VERIFY, HEX);
    digitalWrite(RESET, LOW);

  }
  digitalWrite(TEST0, LOW);
  digitalWrite(EA, LOW);
}
void test() {
  Serial.println("pulsing VDD");
  delay(3500);
  for (int i = 0; i < 5; i++) {
    digitalWrite(VDD, HIGH);
    Serial.println("high");
    delay(1000);
    digitalWrite(VDD, LOW);
    Serial.println("low");
    delay(1000);
  }
  Serial.println("pulsing PROG");
  delay(3500);
  for (int i = 0; i < 5; i++) {
    digitalWrite(PROG, HIGH);
    Serial.println("high");
    delay(1000);
    digitalWrite(PROG, LOW);
    Serial.println("low");
    delay(1000);
  }
  Serial.println("pulsing TEST0");
  delay(3500);
  for (int i = 0; i < 5; i++) {
    digitalWrite(TEST0, HIGH);
    Serial.println("high");
    delay(1000);
    digitalWrite(TEST0, LOW);
    Serial.println("low");
    delay(1000);
  }
  Serial.println("pulsing RESET");
  delay(3500);

  for (int i = 0; i < 5; i++) {
    digitalWrite(RESET, HIGH);
    Serial.println("high");
    delay(1000);
    digitalWrite(RESET, LOW);
    Serial.println("low");
    delay(1000);
  }
}

void error() {
  Serial.println("ABORT WITH ERROR!");
  digitalWrite(EA, LOW);
  digitalWrite(TEST0, LOW);
  digitalWrite(RESET, LOW);
  while (true) {
    digitalWrite(LED, HIGH);
  }
}

void done() {
  Serial.println("Programming DONE");
  digitalWrite(EA, LOW);
  digitalWrite(TEST0, LOW);
  digitalWrite(RESET, LOW);
  while (true) {
    digitalWrite(LED, LOW);
  }
}