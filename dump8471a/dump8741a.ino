/*
   Program to load a payload into a MCS-48 Microcontroller with an Arduino Nano
*/

#include <avr/io.h>

uint8_t payload[1024] =
{
  // Put your Payload (8bit HEX-Values separated by a ",") here and adjust the size of the array and the for-loops in the program-routine accordingly
  0x44, 0x0, 0x22, 0x0, 0x0, 0x0, 0x0, 0x65, 0xD5, 0xB8, 0x17, 0xA0, 0xFB, 0xF2, 0x12, 0x3, 0x1C, 0xB3, 0x24, 0x0, 0x23, 0xFF, 0x62, 0x45, 0xB8, 0x17, 0xF0, 0x93, 0x24, 0x48, 0x52, 0x82, 0x8A, 0xA4, 0x7A, 0xB4, 0x9, 0xF2, 0x3B, 0x53, 0xF, 0xDE, 0x96, 0x14, 0xB8, 0x3, 0xF0, 0xC6, 0x14, 0xA, 0x53, 0x20, 0x4E, 0x43, 0x80, 0x3A, 0x1B, 0x4, 0x14, 0x53, 0xF, 0x47, 0xAA, 0xB9, 0x30, 0x27, 0xAD, 0xAC, 0xBB, 0x2, 0x4, 0x14, 0xB8, 0x3, 0xF0, 0xAD, 0xB9, 0x20, 0xBB, 0x81, 0x24, 0x7, 0x26, 0x6A, 0xB8, 0x4, 0xF0, 0x96, 0x6A, 0x9, 0x53, 0xF, 0xC6, 0x6A, 0xA8, 0xDE, 0xC6, 0x70, 0xF8, 0xD3, 0xF, 0xC6, 0x72, 0xFE, 0xC6, 0x72, 0x9A, 0x20, 0xBB, 0x6, 0x4, 0x14, 0x8A, 0xF, 0xFA, 0x48, 0xA1, 0x19, 0xBB, 0x3, 0x4, 0x14, 0x9A, 0x20, 0x36, 0x14, 0xBB, 0x0, 0x4, 0x24, 0x26, 0x6A, 0x9A, 0x20, 0xBB, 0x4, 0x4, 0x14, 0x9, 0x26, 0x99, 0x53, 0xF, 0xAA, 0xF9, 0x53, 0xF, 0xC6, 0x6A, 0xBB, 0x5, 0x4, 0x14, 0xBB, 0x0, 0xFC, 0x96, 0x14, 0xFD, 0xB8, 0x4, 0xA0, 0x4, 0x14, 0x26, 0x6A, 0x9, 0x53, 0xF, 0x47, 0x4A, 0xA1, 0x19, 0x1D, 0x6C, 0xAC, 0xBB, 0x4, 0x4, 0x14, 0x9, 0x53, 0xF, 0xDE, 0x96, 0x6A, 0x9A, 0x7F, 0x8A, 0x40, 0xFE, 0xAA, 0xBB, 0x80, 0x24, 0x17, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8A, 0x40, 0x53, 0x7F, 0x3, 0x11, 0xB3, 0x9A, 0xBF, 0x23, 0xFF, 0x62, 0x55, 0xB8, 0x17, 0xF0, 0x93, 0x17, 0x51, 0x61, 0x75, 0x87, 0xAA, 0x26, 0x1D, 0x9A, 0x20, 0x4, 0x24, 0x9, 0x53, 0xF, 0xDA, 0xC6, 0x25, 0x4, 0x6A, 0xFA, 0x96, 0x2A, 0xFE, 0xAA, 0x3, 0xF2, 0xE6, 0x30, 0xBA, 0x0, 0x1A, 0xFE, 0xDA, 0xC6, 0x3E, 0xA, 0x53, 0x20, 0x4A, 0x43, 0x40, 0x3A, 0x24, 0x7, 0xB8, 0x3, 0xF0, 0xC6, 0x25, 0xAD, 0xB9, 0x20, 0xA, 0x53, 0x20, 0x4A, 0x43, 0xC0, 0x3A, 0xBB, 0x81, 0x24, 0x7, 0xA, 0x53, 0x20, 0xA8, 0xF1, 0x53, 0xF, 0x43, 0xC0, 0x48, 0x3A, 0x19, 0xBB, 0x82, 0x24, 0x7, 0x9, 0x53, 0xF, 0xD3, 0xF, 0x96, 0x6D, 0xAC, 0xBB, 0x83, 0x24, 0x7, 0xEF, 0xAA, 0x27, 0xB8, 0x3, 0xA0, 0x24, 0xAA, 0xA, 0x53, 0x20, 0xA8, 0xF1, 0x53, 0xF, 0x43, 0xC0, 0x48, 0x3A, 0xF1, 0x6C, 0xAC, 0xBB, 0x84, 0x24, 0x7, 0xA, 0x53, 0x20, 0xA8, 0xF1, 0x47, 0x53, 0xF, 0x43, 0xC0, 0x48, 0x3A, 0xED, 0x9D, 0x27, 0xB8, 0x3, 0xA0, 0xBB, 0x85, 0x24, 0x7, 0x19, 0xBB, 0x83, 0xFD, 0x7, 0x96, 0x7, 0xFC, 0x37, 0x17, 0xA1, 0x24, 0x7, 0x9A, 0x60, 0xBA, 0x0, 0xBB, 0x80, 0x24, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x27, 0xD7, 0x90, 0x3A, 0x89, 0xFF, 0x27, 0xB8, 0x2, 0xB9, 0x3E, 0xA0, 0x18, 0xE9, 0xB, 0x23, 0xF, 0xB8, 0x1E, 0xA0, 0xBD, 0xA, 0x23, 0x22, 0xB8, 0x16, 0xA0, 0x54, 0x23, 0x74, 0x0, 0x54, 0x2F, 0x44, 0x1D, 0x9A, 0x20, 0xD5, 0xBB, 0x6, 0x25, 0x23, 0xFF, 0x62, 0x45, 0xC5, 0x83, 0x9, 0x53, 0xCF, 0xB8, 0x15, 0xD0, 0xC6, 0x3F, 0xD0, 0xA0, 0x85, 0x27, 0xB8, 0x14, 0xA0, 0x83, 0xB8, 0x14, 0xF0, 0x7, 0xA0, 0x96, 0x3E, 0x65, 0xB6, 0x4A, 0x95, 0x9, 0x53, 0xCF, 0x96, 0x23, 0xB8, 0x1E, 0xF0, 0xD3, 0xF, 0xC6, 0x23, 0x9, 0x53, 0xCF, 0x96, 0x23, 0x65, 0xD5, 0xA, 0x53, 0x20, 0x4E, 0x43, 0x80, 0x3A, 0xFE, 0x37, 0x62, 0xBB, 0x7, 0x55, 0xC5, 0x83, 0xB8, 0x0, 0xFB, 0xC6, 0x73, 0xB8, 0x40, 0xD5, 0xFF, 0xC5, 0x96, 0x7C, 0xF8, 0x43, 0x20, 0xA8, 0xFC, 0xC6, 0x83, 0xF8, 0x43, 0x80, 0xA8, 0xF8, 0x83, 0xA8, 0xD3, 0x40, 0x5E, 0xC6, 0x92, 0xF8, 0x43, 0x10, 0x90, 0x8A, 0x20, 0x83, 0xF8, 0x53, 0xEF, 0x90, 0x9A, 0xDF, 0x83, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xF9, 0xC6, 0x3F, 0x3, 0xD0, 0xE6, 0x24, 0x54, 0x6C, 0x53, 0x7F, 0x54, 0x85, 0xB8, 0x0, 0xD6, 0x17, 0xBC, 0x0, 0xB9, 0x0, 0x64, 0x3F, 0x86, 0x21, 0xF1, 0x19, 0x2, 0xEC, 0xF, 0xB9, 0x0, 0x83, 0xE8, 0xF, 0x83, 0x54, 0x6C, 0x43, 0x40, 0x54, 0x85, 0xB8, 0x0, 0xD6, 0x3C, 0x76, 0x13, 0x22, 0xA1, 0x19, 0xEA, 0x2C, 0xF9, 0x3, 0xE0, 0xAB, 0xB9, 0x0, 0x83, 0xE8, 0x2C, 0x83, 0x54, 0x6C, 0x54, 0x85, 0xD6, 0x49, 0x22, 0x76, 0x4A, 0xAA, 0x83, 0xA8, 0xF2, 0x4F, 0x64, 0x5A, 0x53, 0x3F, 0x28, 0xD2, 0x57, 0xFA, 0xA0, 0x83, 0xF0, 0x2, 0x83, 0xF8, 0x3, 0xF3, 0xF6, 0x63, 0xF8, 0x3, 0x64, 0xB3, 0x83, 0x63, 0x71, 0x74, 0x7B, 0x93, 0x9C, 0x9F, 0xA2, 0xA9, 0xB2, 0xB7, 0xBC, 0xC1, 0x35, 0x4, 0x0, 0xFA, 0x53, 0xF, 0xB8, 0x1E, 0xA0, 0x83, 0xB8, 0x1E, 0xF0, 0xC6, 0x92, 0xD3, 0xF, 0xC6, 0x92, 0xFD, 0xB8, 0x1F, 0xA0, 0xFA, 0x7, 0x3, 0xF1, 0xF6, 0x92, 0xB9, 0x20, 0x64, 0x24, 0x83, 0xFC, 0x2, 0xC6, 0x9B, 0xB9, 0x30, 0x64, 0x7, 0x83, 0xFA, 0xAD, 0x83, 0xBC, 0x0, 0x83, 0xBB, 0x0, 0xFD, 0xB8, 0x1F, 0xA0, 0x83, 0xFE, 0x43, 0x80, 0xAE, 0x54, 0x6C, 0x54, 0x85, 0x83, 0xFE, 0x43, 0x40, 0x64, 0xAC, 0xFE, 0x53, 0x7F, 0x64, 0xAC, 0xFE, 0x53, 0xBF, 0x64, 0xAC, 0xFE, 0x2, 0x83, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 
} ;
int d = 200;
int VDD = A0;
int PROG = A1;
int TEST0 = A2;
int RESET = A3;
//int EA = A4;
int BUTTON = A5;
int LED = 13;
int DataBus0 = 2;
int DataBus1 = 3;
int DataBus2 = 4;
int DataBus3 = 5;
int DataBus4 = 6;
int DataBus5 = 7;
int DataBus6 = 8;
int DataBus7 = 9;
int P20 = 10;
int P21 = 11;
int P22 = 12;

uint8_t LOWBYTE = 0;
uint8_t HIGHBYTE = 0;


void setup() {
  // Setup the Control-Pins
  Serial.begin(500000);
  pinMode(LED, OUTPUT);
  digitalWrite(LED, LOW);
  pinMode(VDD, OUTPUT);
  pinMode(PROG, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  //pinMode(EA, OUTPUT);
  pinMode(BUTTON, INPUT_PULLUP);
  // Setup the Address-/Data-Pins to INPUT, to keep them floating for now
  //DDRD = DDRD | B00000000;
  //DDRB = B00000000;
  // Set the control-Pins according to MCS-48 recommendation
  digitalWrite(VDD, LOW); // Set VDD to +5V
  digitalWrite(PROG, LOW); // Set PROG to +5V
  digitalWrite(TEST0, HIGH); // Set TEST0 to +5V
  //digitalWrite(EA, LOW); // Set EA to +5V
  digitalWrite(RESET, LOW); // Set RESET to 0V
  Serial.println("MCS-48 Programmer READY");
}

void loop() {
  if (digitalRead(BUTTON) == LOW) {
    Serial.println("button pressed");
    delay(1000);

    //Serial.println("Dumping Chip in 5 seconds");
    //delay(5000);
    //dump();

    Serial.println("Programming Chip in 5 Seconds");
    delay(5000);
    programverify();

  }
}

void programverify() {

  //Serial.println("Doing blank-check...");
  //if (dump() == true) {
  //  Serial.println("Chip is not blank, aborting...");
  //  return;
  //}
  
  pinMode(LED, OUTPUT);
  pinMode(VDD, OUTPUT);
  pinMode(PROG, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  digitalWrite(TEST0, HIGH); //test0 to 5v
  //digitalWrite(EA, HIGH); // apply +18V to EA to activate Programming-Mode
  digitalWrite(RESET, HIGH); //reset high while doing nothing
  digitalWrite(VDD, LOW); //low unless programming
  digitalWrite(PROG, LOW); //low unless programming

  pinMode(P20, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P21, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P22, OUTPUT); //extra address lines more than the data bus can accomodate

  delayMicroseconds(d);

  bool success = true;
  
  for (uint16_t i = 0; i < 2048; i++) {

    /////////////////////////
    digitalWrite(TEST0, LOW);
    delayMicroseconds(d);
    
    // Setup the pins as outputs
    pinMode(DataBus0, OUTPUT);
    pinMode(DataBus1, OUTPUT);
    pinMode(DataBus2, OUTPUT);
    pinMode(DataBus3, OUTPUT);
    pinMode(DataBus4, OUTPUT);
    pinMode(DataBus5, OUTPUT);
    pinMode(DataBus6, OUTPUT);
    pinMode(DataBus7, OUTPUT);
    Serial.print("Programming Address ");
    Serial.print(i, HEX);


    //digitalWrite(RESET, LOW); //reset low while setting addresses

    //set address lines to bits in the address (remember, we have 10 bits in the 8041 and 11 in the 8042)
    if((i & 0x0001)>0) 
    {
      digitalWrite(DataBus0, 1);
    } else {
      digitalWrite(DataBus0, 0);
    }

    if((i & 0x0002)>0) 
    {
      digitalWrite(DataBus1, 1);
    } else {
      digitalWrite(DataBus1, 0);
    }

    if((i & 0x0004)>0) 
    {
      digitalWrite(DataBus2, 1);
    } else {
      digitalWrite(DataBus2, 0);
    }

    if((i & 0x0008)>0) 
    {
      digitalWrite(DataBus3, 1);
    } else {
      digitalWrite(DataBus3, 0);
    }

    if((i & 0x0010)>0) 
    {
      digitalWrite(DataBus4, 1);
    } else {
      digitalWrite(DataBus4, 0);
    }

    if((i & 0x0020)>0) 
    {
      digitalWrite(DataBus5, 1);
    } else {
      digitalWrite(DataBus5, 0);
    }

    if((i & 0x0040)>0) 
    {
      digitalWrite(DataBus6, 1);
    } else {
      digitalWrite(DataBus6, 0);
    }

    if((i & 0x0080)>0) 
    {
      digitalWrite(DataBus7, 1);
    } else {
      digitalWrite(DataBus7, 0);
    }

    if((i & 0x0100)>0) 
    {
      digitalWrite(P20, 1);
    } else {
      digitalWrite(P20, 0);
    }
      
    if((i & 0x0200)>0) 
    {
      digitalWrite(P21, 1);
    } else {
      digitalWrite(P21, 0);
    }
      
    if((i & 0x0400)>0) 
    {
      digitalWrite(P22, 1);
    } else {
      digitalWrite(P22, 0);
    }

    delayMicroseconds(d);                         // Wait 10ms to have stable lines (Taw)
    digitalWrite(RESET, HIGH);        // Latch the Address into the MCS-48 µC
    delayMicroseconds(d);                         // Give the µC some time to latch the Address (Twa)

    Serial.print("   For Data ");
    Serial.print(payload[i % 1024], HEX);

    digitalWrite(DataBus0, payload[i % 1024] & 0x0001);
    digitalWrite(DataBus1, payload[i % 1024] & 0x0002);
    digitalWrite(DataBus2, payload[i % 1024] & 0x0004);
    digitalWrite(DataBus3, payload[i % 1024] & 0x0008);
    digitalWrite(DataBus4, payload[i % 1024] & 0x0010);
    digitalWrite(DataBus5, payload[i % 1024] & 0x0020);
    digitalWrite(DataBus6, payload[i % 1024] & 0x0040);
    digitalWrite(DataBus7, payload[i % 1024] & 0x0080);

    delayMicroseconds(d);                      // Wait 10ms to have stable lines (Tdw)
    digitalWrite(VDD, HIGH); //getting ready to program
    delayMicroseconds(d);                          // Wait 10ms to have stable lines (Tvddw)
    digitalWrite(PROG, HIGH); //programming
    delayMicroseconds(d);                          // Wait 10ms to have stable lines (Tpw)
    digitalWrite(PROG, LOW); //programming over
    delayMicroseconds(d);                         // Wait 10ms to have stable lines (Tvddh)
    digitalWrite(VDD, LOW); //finish programming
    delayMicroseconds(d);                         // Wait 10ms to have stable lines (Twt)

    //verifying

    pinMode(DataBus0, INPUT);
    pinMode(DataBus1, INPUT);
    pinMode(DataBus2, INPUT);
    pinMode(DataBus3, INPUT);
    pinMode(DataBus4, INPUT);
    pinMode(DataBus5, INPUT);
    pinMode(DataBus6, INPUT);
    pinMode(DataBus7, INPUT);

    delayMicroseconds(d);
    
    digitalWrite(TEST0, HIGH); //test0 to 5v for reading
    delayMicroseconds(d);      // Wait 25ms to have stable lines (Tdo)

    uint8_t VERIFY = 0;
    if (digitalRead(DataBus0)) {
      VERIFY = VERIFY + 0x01;
    }
    if (digitalRead(DataBus1)) {
      VERIFY = VERIFY + 0x02;
    }
    if (digitalRead(DataBus2)) {
      VERIFY = VERIFY + 0x04;
    }
    if (digitalRead(DataBus3)) {
      VERIFY = VERIFY + 0x08;
    }
    if (digitalRead(DataBus4)) {
      VERIFY = VERIFY + 0x10;
    }
    if (digitalRead(DataBus5)) {
      VERIFY = VERIFY + 0x20;
    }
    if (digitalRead(DataBus6)) {
      VERIFY = VERIFY + 0x40;
    }
    if (digitalRead(DataBus7)) {
      VERIFY = VERIFY + 0x80;
    }

    delayMicroseconds(d);
    
    Serial.print(" Read: ");
    Serial.print(VERIFY, HEX);
    if (VERIFY == payload[i % 1024]) {
      Serial.println(" OK");
      digitalWrite(LED, HIGH);
    }
    else {
      Serial.println(" ERROR");
      success = false;
      // error();
    }
    digitalWrite(RESET, LOW);
    
    delayMicroseconds(d);
  }
  //digitalWrite(TEST0, LOW);
  //digitalWrite(EA, LOW);

  Serial.println();
  if (success) {
    Serial.print("ProgramVerify SUCCESS");
  } else {
    Serial.print("ProgramVerify FAILED");
  }
}

// Returns false if blank
bool dump() {

  bool blank = true;
  
  pinMode(LED, OUTPUT);
  pinMode(VDD, OUTPUT);
  pinMode(PROG, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  digitalWrite(TEST0, HIGH); //test0 to 5v
  //digitalWrite(EA, HIGH); // apply +18V to EA to activate Programming-Mode
  //digitalWrite(RESET, HIGH); //reset high while doing nothing

  pinMode(P20, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P21, OUTPUT); //extra address lines more than the data bus can accomodate
  pinMode(P22, OUTPUT); //extra address lines more than the data bus can accomodate

  for (uint16_t i = 0; i < 2048; i++) {

    /////////////////////////
    digitalWrite(TEST0, LOW);
    delayMicroseconds(d);
    
    // Setup the pins as outputs
    pinMode(DataBus0, OUTPUT);
    pinMode(DataBus1, OUTPUT);
    pinMode(DataBus2, OUTPUT);
    pinMode(DataBus3, OUTPUT);
    pinMode(DataBus4, OUTPUT);
    pinMode(DataBus5, OUTPUT);
    pinMode(DataBus6, OUTPUT);
    pinMode(DataBus7, OUTPUT);
    //if ((i % 32) == 0) {
      //Serial.print("Reading Address ");
      //Serial.print(i, HEX);
      //Serial.println();
    //}

    //digitalWrite(RESET, LOW); //reset low while setting addresses


    //set address lines to bits in the address (remember, we have 10 bits in the 8041 and 11 in the 8042)
    
    if((i & 0x0001)>0) 
    {
      digitalWrite(DataBus0, 1);
    } else {
      digitalWrite(DataBus0, 0);
    }

    if((i & 0x0002)>0) 
    {
      digitalWrite(DataBus1, 1);
    } else {
      digitalWrite(DataBus1, 0);
    }

    if((i & 0x0004)>0) 
    {
      digitalWrite(DataBus2, 1);
    } else {
      digitalWrite(DataBus2, 0);
    }

    if((i & 0x0008)>0) 
    {
      digitalWrite(DataBus3, 1);
    } else {
      digitalWrite(DataBus3, 0);
    }

    if((i & 0x0010)>0) 
    {
      digitalWrite(DataBus4, 1);
    } else {
      digitalWrite(DataBus4, 0);
    }

    if((i & 0x0020)>0) 
    {
      digitalWrite(DataBus5, 1);
    } else {
      digitalWrite(DataBus5, 0);
    }

    if((i & 0x0040)>0) 
    {
      digitalWrite(DataBus6, 1);
    } else {
      digitalWrite(DataBus6, 0);
    }

    if((i & 0x0080)>0) 
    {
      digitalWrite(DataBus7, 1);
    } else {
      digitalWrite(DataBus7, 0);
    }

    if((i & 0x0100)>0) 
    {
      digitalWrite(P20, 1);
    } else {
      digitalWrite(P20, 0);
    }
      
    if((i & 0x0200)>0) 
    {
      digitalWrite(P21, 1);
    } else {
      digitalWrite(P21, 0);
    }
      
    if((i & 0x0400)>0) 
    {
      digitalWrite(P22, 1);
    } else {
      digitalWrite(P22, 0);
    }

    delayMicroseconds(d);                         // Wait 1ms to have stable lines (Taw)
    
    digitalWrite(RESET, HIGH);        // Latch the Address into the MCS-48 µC
    
    delayMicroseconds(d);                         // Give the µC some time to latch the Address (Twa)

    
    pinMode(DataBus0, INPUT);
    pinMode(DataBus1, INPUT);
    pinMode(DataBus2, INPUT);
    pinMode(DataBus3, INPUT);
    pinMode(DataBus4, INPUT);
    pinMode(DataBus5, INPUT);
    pinMode(DataBus6, INPUT);
    pinMode(DataBus7, INPUT);
    
    delayMicroseconds(d);

    /////////////////////////
    digitalWrite(TEST0, HIGH);
    delayMicroseconds(d);

    uint8_t VERIFY = 0;
    if (digitalRead(DataBus0)) {
      VERIFY = VERIFY + 0x01;
    }
    if (digitalRead(DataBus1)) {
      VERIFY = VERIFY + 0x02;
    }
    if (digitalRead(DataBus2)) {
      VERIFY = VERIFY + 0x04;
    }
    if (digitalRead(DataBus3)) {
      VERIFY = VERIFY + 0x08;
    }
    if (digitalRead(DataBus4)) {
      VERIFY = VERIFY + 0x10;
    }
    if (digitalRead(DataBus5)) {
      VERIFY = VERIFY + 0x20;
    }
    if (digitalRead(DataBus6)) {
      VERIFY = VERIFY + 0x40;
    }
    if (digitalRead(DataBus7)) {
      VERIFY = VERIFY + 0x80;
    }

    delayMicroseconds(d);

    if (VERIFY != 0x00) {
      blank = false;
    }
    //Serial.print(" : ");
    //Serial.println(VERIFY, HEX);
    Serial.print("0x");
    Serial.print(VERIFY, HEX);
    Serial.print(", ");
    //if ((i % 32) == 31)
    //  Serial.println();
    
    digitalWrite(RESET, LOW);
    
    delayMicroseconds(d);
  }
  
  //digitalWrite(TEST0, LOW);
  //digitalWrite(EA, LOW);
  
    Serial.println();
    Serial.println("done");

    if (blank)
      return false;
    else
      return true;
}

